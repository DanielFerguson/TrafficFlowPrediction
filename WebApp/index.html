<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Traffic Flow</title>

  <!-- Lodash -->
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"
    integrity="sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=" crossorigin="anonymous"></script>

  <!-- Axios -->
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

  <!-- MapBox -->
  <script src='https://api.mapbox.com/mapbox-gl-js/v1.2.0/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v1.2.0/mapbox-gl.css' rel='stylesheet' />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
    integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
    crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
    integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
    crossorigin=""></script>

  <!-- FontAwesome -->
  <link href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" rel="stylesheet">

  <!-- UTF-8 Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/utf8/3.0.0/utf8.min.js"></script>

  <!-- VueJS -->
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

  <!-- Vuetify -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@3.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>

  <!-- Vue Multiselect -->
  <script src="https://unpkg.com/vue-multiselect@2.1.0"></script>
  <link rel="stylesheet" href="https://unpkg.com/vue-multiselect@2.1.0/dist/vue-multiselect.min.css">

  <!-- Turfjs -->
  <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>

  <!-- Tensorflow -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>

  <!-- SCAT Locations Data -->
  <script src="./groups.js"></script>

  <!-- Stylesheet -->
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="app">
    <v-app>
      <div class="map" id="mapid"></div>

      <div class="search-box">
        <div class="multiselect select mb-2">
          <div class="multiselect__tags">

            <div class="row">
              <div class="col-2">
                <input type="number" id="inputHour" value="10" class="form-control">
              </div>

              <div class="col-2">
                <input type="number" id="inputHour" value="30" class="form-control">
              </div>

              <div class="col-2 text-center">
                <select class="custom-select mr-sm-2">
                  <option selected value="AM">AM</option>
                  <option value="PM">PM</option>
                </select>
              </div>

              <div class="col-3 text-center">
                <select class="custom-select mr-sm-2">
                  <option selected value="weekday">Weekday</option>
                  <option value="weekend">Weekend</option>
                </select>
              </div>

              <div class="col-3 text-center">
                <select class="custom-select mr-sm-2" @change="UpdateSearchMethod($event)">
                  <option selected value="location">Location</option>
                  <option value="scat">SCAT Site</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <multiselect v-if="search_type == 'location'" class="select" v-model="search_origin" label="text"
          placeholder="Origin" :options="to_options" @search-change="GeocodeFrom"></multiselect>

        <multiselect v-else class="select" v-model="scat_origin" placeholder="Origin" :options="scat_sites"
          @search-change="console.log('hello')"></multiselect>

        <transition name="fade">
          <multiselect v-if="search_origin" class="select top-space" v-model="search_destination" label="text"
            placeholder="Destination" :options="from_options" @search-change="GeocodeTo"></multiselect>

          <multiselect v-if="scat_origin" class="select top-space" v-model="scat_destination" placeholder="Destination"
            :options="scat_sites" @search-change="console.log('there')"></multiselect>
        </transition>
      </div>

      <transition name="slide">
        <div class="container options-box" style="right: 0;" v-if="search_destination || scat_destination">
          <div class="row">
            <h2 class="mb-2">Options</h2>
            <span class="ml-auto">
              Sort By:
              <select class="custom-select my-1 mr-sm-2">
                <option selected value="dist">Distance</option>
                <option value="time">Estimated Time</option>
              </select>
            </span>
          </div>

          <div>
            <div class="card option-card mb-3" v-for="i in 5">
              <div class="card-body option-card-body" :option="'option' + i" @click="SelectRoute(i)">
                <h3 class="card-title">Route #{{i}}</h3>
                <h6 class="card-subtitle text-muted">Distance: 24.32kms</h6>
                <h6 class="card-subtitle text-muted">Estimated Time: 12mins</h6>
              </div>
            </div>
          </div>
        </div>
      </transition>
    </v-app>
  </div>
  <script>
    var userSetIcon = L.icon({
      iconUrl: './assets/red_marker.png',
      iconSize: [36, 41],
      iconAnchor: [18, 41],

      popupAnchor: [-3, -76]
    });

    var paths = [];
    var temp_paths = [];

    var options = [];

    Vue.component('multiselect', window.VueMultiselect.default);

    var app = new Vue({
      el: '#app',
      vuetify: new Vuetify(),
      icons: {
        iconfont: 'fa',
      },
      mounted: function () {
        this.InitialiseMap();
      },
      data: {
        to_options: [],
        from_options: [],

        map: null,

        search_type: 'location',

        entry_point: null,
        exit_point: null,

        routes: [],

        final_distance: null,

        search_origin: '',
        search_destination: '',
        scat_origin: '',
        scat_destination: ''
      },
      computed: {
        scat_sites: function () {
          var list = [];
          groups.forEach(site => {
            list.push(site.scat_id)
          });
          return list;
        }
      },
      watch: {
        search_type: function () {
          // When this is changed, reset all input vars
          this.search_origin = '';
          this.search_destination = '';
          this.scat_origin = '';
          this.scat_destination = '';
          this.routes = [];
        },
        search_origin: function () {
          var lat = this.search_origin.geometry.coordinates[1];
          var lng = this.search_origin.geometry.coordinates[0];

          // Add Point Marker to map
          L.marker([lat, lng], {
            icon: userSetIcon
          }).addTo(this.map);

          // Link to the closest Marker
          var result = this.FindNearestPoint(lat, lng);
          this.entry_point = result.nearest;

          // Draw line between points
          this.DrawLine([
            [lat, lng],
            [result.nearest.lat, result.nearest.lng]
          ], 'red', true);
        },
        search_destination: function () {
          var lat = this.search_destination.geometry.coordinates[1];
          var lng = this.search_destination.geometry.coordinates[0];

          // Add Point Marker to map
          L.marker([lat, lng], {
            icon: userSetIcon
          }).addTo(this.map);

          // Link to the closest Marker
          var result = this.FindNearestPoint(lat, lng);
          this.exit_point = result.nearest;

          // Draw line between points
          this.DrawLine([
            [lat, lng],
            [result.nearest.lat, result.nearest.lng]
          ], 'red', true);

          // Generate routes
          for (let i = 0; i < 5; i++) {
            this.routes.push(this.GenerateRoute());
          }
        }
      },
      methods: {
        SelectRoute: function (event) {
          console.log('Select route #' + event);
        },
        UpdateSearchMethod: function (event) {
          this.search_type = event.target.value;
        },


        GenerateRoute: function () {
          var starting_point = this.entry_point;
          var current_point = starting_point;

          var steps = [starting_point]; // A list of all nodes travelled to/from, initalized with entry point
          var total_distance = 0; // Total distance travelled

          // Generate Seeded Starting Point
          var num_steps = Math.floor(Math.random() * 5) + 1; // Generates a random int between 0 to 5
          var step_index = 0; // Current index

          for (let i = 0; i < num_steps; i++) {
            // First - Find the next point
            var next_point_id = null;

            if (starting_point.neighbours.length == 1) {
              // If only one neighbour, traverse to that neighbour
              next_point_id = current_point.neighbours[0];

            } else {
              // If there are more than one neighbour, pick a random direction to go  
              var num_neighbours = current_point.neighbours.length;
              var neighbour_selection = Math.floor(Math.random() * (num_neighbours + 1));

              next_point_id = current_point.neighbours[neighbour_selection];
            }

            // Get the object for the scat_id
            var next_point_obj = _.find(groups, ['scat_id', next_point_id]);

            // Find the distance between current_point --> next_point, record it in total_distance
            total_distance += this.CalculateDistance([next_point_obj.lat, next_point_obj.lng], [current_point.lat, current_point.lng]);

            // Push the record of the traversal onto steps
            steps.push(next_point_id);

            // Set the current_point to the found object of the next_point in groups
            current_point = next_point_obj;
          }

          // Second - Find the quickest path from seeded location
          var next_point_id = null;

          while (current_point != this.exit_point) {
            if (current_point.neighbours.includes(this.exit_point.scat_id)) {
              // Check if one of the neighbours is the end point

              // Get the object for the scat_id
              var next_point_obj = this.exit_point;

              // Find the distance between current_point --> next_point, record it in total_distance
              total_distance += this.CalculateDistance([next_point_obj.lat, next_point_obj.lng], [current_point.lat, current_point.lng]);

              // Push the record of the traversal onto steps
              steps.push(next_point_id);

              // Set the current_point to the found object of the next_point in groups
              current_point = next_point_obj;

            } else if (current_point.neighbours.length == 1) {

              // If only one neighbour, traverse to that neighbour
              next_point_id = current_point.neighbours[0];

            } else {
              // There are more than 1 neighbours, evaluate which is closest to line

              // Generate a Line of Sight from the point; this will help us make informed decisions about 
              // the best neighbour to traverse to
              var los_line = turf.lineString([
                [current_point.lat, current_point.lng],
                [this.exit_point.lat, this.exit_point.lng]
              ]);

              // TODO: Check that this isnt the previous step (stopping a potential infinite loop).
              var closest_distance = 100;

              current_point.neighbours.forEach(n_id => {
                var n_obj = _.find(groups, ['scat_id', n_id]);

                var dist_to_end = this.CalculateDistance(
                  [parseFloat(n_obj.lat), parseFloat(n_obj.lng)], 
                  [this.exit_point.lat, this.exit_point.lng]
                );

                if (dist_to_end < closest_distance) {
                  next_point_id = n_id;
                }
              });

              // Get the object for the scat_id
              var next_point_obj = _.find(groups, ['scat_id', next_point_id]);

              // Find the distance between current_point --> next_point, record it in total_distance
              total_distance += this.CalculateDistance([next_point_obj.lat, next_point_obj.lng], [current_point.lat, current_point.lng]);

              // Push the record of the traversal onto steps
              steps.push(next_point_id);

              // Set the current_point to the found object of the next_point in groups
              current_point = next_point_obj;
            }

          }

          return {'steps': steps, 'distance': total_distance};
        },

        // Accumulative Function
        InitialiseMap: function () {
          this.map = L.map('mapid', {
            zoomControl: false
          }).setView([-37.8131, 145.0678], 13);

          // Initialise Map
          L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
            maxZoom: 18,
            id: 'mapbox.streets',
            accessToken: 'pk.eyJ1IjoiZGFuaWVsZmVyZ3Vzb24iLCJhIjoiY2pzeWhhYmVyMHBneTQ0cXgydXJoeDUxMCJ9.LD82Xcdk-WD3a5TMcvdwEg'
          }).addTo(this.map);

          // Create Markers
          groups.forEach(location => {
            var lat = location['lat'];
            var lng = location['lng'];
            var id = location['scat_id'];

            L.marker([lat, lng]).bindPopup("<b>Scat ID: " + id + "</b>").on('click', this.DrawNeighbourConnections).addTo(this.map);
          });
        },
        DrawNeighbourConnections: function (marker) {
          // Remove all current connections
          this.RemoveLines();
          temp_paths = [];

          // Get the object of the selected marker
          var obj = _.find(groups, {
            'lat': marker.latlng.lat.toString(),
            'lng': marker.latlng.lng.toString()
          });

          // Get the objects for the selected markers neighbours
          var neighbour_objs = [];

          obj.neighbours.forEach(neighbour => {

            // Draw a line from the selected marker to the neighbour marker
            var n_obj = _.find(groups, ['scat_id', neighbour]);

            this.DrawLine([
              [obj.lat, obj.lng],
              [n_obj.lat, n_obj.lng]
            ], 'blue', false);
          });
        },

        // Mapping & Drawing Functions
        FindNearestPoint: function (lat, lng) {
          var points = [];

          // Create array of Turn Points
          groups.forEach(point => {
            points.push(
              turf.point([parseFloat(point.lat), parseFloat(point.lng)])
            );
          });

          var origin_point = turf.point([lat, lng]);

          // Find nearest Point
          var nearest_pos = turf.nearestPoint(origin_point, turf.featureCollection(points));

          // Get the Object for the nearest Point & distance to
          var nearest_obj = groups[nearest_pos.properties.featureIndex];
          var distance_to = nearest_pos.properties.distanceToPoint;

          return {
            'nearest': nearest_obj,
            'distance': distance_to
          };
        },
        CalculateDistance: function (pointOne, pointTwo) {
          var from = turf.point([pointOne[0], pointOne[1]]);
          var to = turf.point([pointTwo[0], pointTwo[1]]);
          var options = {
            units: 'kilometers'
          };

          return turf.distance(from, to, options);
        },
        DrawLine: function (latlngs, colour, notTemp) {
          var pointOne = [parseFloat(latlngs[0][0]), parseFloat(latlngs[0][1])];
          var pointTwo = [parseFloat(latlngs[1][0]), parseFloat(latlngs[1][1])];

          var l = L.polyline([latlngs], {
            color: colour
          }).bindPopup("Distance: <b>" + this.CalculateDistance(pointOne, pointTwo).toFixed(2) + "kms</b>").addTo(this.map);

          // If temp (starting/ending lines) verticies, add to the temp directory 
          notTemp
            ? paths.push(l)
            : temp_paths.push(l);
        },
        RemoveLines: function () {
          temp_paths.forEach(path => {
            this.map.removeLayer(path);
          });
        },

        // Geocoding Functions
        GenerateURL: function (query) {
          return "https://api.mapbox.com/geocoding/v5/mapbox.places/" + encodeURI(query) + ".json?access_token=pk.eyJ1IjoiZGFuaWVsZmVyZ3Vzb24iLCJhIjoiY2pzeWhhYmVyMHBneTQ0cXgydXJoeDUxMCJ9.LD82Xcdk-WD3a5TMcvdwEg&country=au";
        },
        GeocodeFrom: function (searchQuery, id) {
          if (searchQuery) {
            axios
              .get(this.GenerateURL(searchQuery))
              .then((response) => {
                this.to_options = response.data.features
              })
              .catch((error) => (console.log(error)))
          }
        },
        GeocodeTo: function (searchQuery, id) {
          if (searchQuery) {
            axios
              .get(this.GenerateURL(searchQuery))
              .then((response) => {
                this.from_options = response.data.features
              })
              .catch((error) => (console.log(error)))
          }
        }
      }
    })
  </script>
</body>

</html>